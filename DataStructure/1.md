# **데이터 구조와 알고리즘, 자료형, 빅 오 표기법**

## 데이터 구조

- **데이터 구조**는 데이터를 구성하고 저장하는 방법을 설명하며, 데이터를 식별하는 방법을 제공하고 데이터의 관계를 보여주는 개념이다.
- 간단하게 데이터를 담은 컨테이너 쯤으로 생각해도 좋다.

## 알고리즘

- **알고리즘**은 문제를 해결하기 위해 사용하는 일련의 단계다.
- 달리 말하면 정해진 순서대로 문제를 해결하는 방법이며 간단히 '절차'라고도 할 수 있다.

## 데이터 구조와 알고리즘의 관계

- 데이터 구조와 알고리즘은 **서로 다른 개념이면서 상호 보완적**이다.
- 데이터 구조는 알고리즘이 다루는 데이터를 구성하며, 알고리즘이 데이터를 처리하고 사용자가 원하는 완전한 정보를 산출하는 과정에서 필요한 부분을 제공한다.

<hr>

## 기본 자료형

- **자료형**은 처리할 데이터의 속성이 무엇인지, 데이터로 수행하려는 작업이 무엇인지 컴퓨터에 알려주려고 만든 것이다.
- 처리할 자료형의 종류가 무엇인지 컴퓨터에 알려줄 때 사용하는 여러 이름을 **기본 자료형**이라고 한다.
- 프로그래밍 언어의 자료형은 대부분 저마다 고유한 이름을 갖지만, 큰 틀에서 보면 모두 **C 기반의 자료형**에 기인한다.

### 기본 자료형 네 가지는 다음과 같다.

- ### **불(boolean)**
- ### **문자(character)**
- ### **정수(integer)**
- ### **부동 소수점 수(floating-point number)**
<hr>

## 불(Boolean)

- **불**은 **논리 자료형**으로 참과 거짓, 0과 1, 켜기와 끄기 등 두 가지 상태를 표현할 수 있다.
- 불은 전통적 컴퓨팅 분야의 핵심이라고 할 수 있는 자료형이다.
- 전통적 컴퓨터에는 켜고 끌 수 있는 수많은 트랜지스터로 구성된 프로세서가 장착되어 있다.
- 수많은 트랜지스터를 켜고 끔으로써 복잡한 연산, 데이터 저장 등 전통적인 컴퓨팅 환경에서 상상할 수 있는 모든 메커니즘이 구현된다.

## 문자(Character)

- **문자**는 문자 자료형으로 문자 하나를 표현한다.
- 문자는 문자열을 구성하는데 사용된다.

## 정수(Integer)

- **정수**는 정수 자료형으로 수학적으로 자연수, 0, 음의 정수를 표현한다.
- 단, 수학에서의 정수는 무한하지만, 컴퓨터 과학에서 정수는 CPU Architecture와 메모리 용량의 한계, 프로그래밍 언어에 정해져 잇는 정수 범위의 제한 때문에 무한하지는 않다.

## 부동 소수점 수(Floating-point number)

- **부동 소수점 수**는 6.5나 7.1과 같은 소수를 표현할 수 있다.
- 소수점이라고 부르는 작은 점(.)의 위치가 숫자를 정밀하게 표현하기 위해 어딘가 떠다니는 것처럼 움직이기 때문에 부동점(floating point)이라는 이름이 붙었고, 한국어로 번역하는 과정에서 부동 소수점이 되었다.
- 부동 소수점의 정밀도는 단정도(single precision)와 배정도(double precision)로 나뉜다.
- 단정도는 32비트, 배정도는 64비트로 표현된다.
- 그래서 단정도 부동 소수점 수를 표현하는 자료형을 **float**, 배정도 부동 소수점 수를 표현하는 자료형을 **double**이라고 구분한다.

<hr>

## 함수

- **함수**는 컴퓨터 과학과 밀접하게 관련된 수학적 개념이다.
- 프로그래밍에서의 함수는 특정 동작을 수행하는 코드 덩어리를 뜻한다.

## 함수, 메소드, 프로시저, 서브루틴

- 프로그래밍에서의 함수는 **매개변수(파라미터)** 또는 **인수**라고 하는 데이터를 입력으로 사용하며 때로는 결과를 반환하기도 한다.
- 프로그래밍에서의 함수는 아무런 결과도 반환하지 않을 수 있다.\
  -C 기반의 프로그래밍 언어에서는 이를 **void** 함수라고 한다.
- **객체 지향 프로그래밍 언어**에 속하는 프로그래밍 언어에서는 다른 코드의 청사진 역할을 하는 특수한 코드가 존재한다.
- 이를 **클래스**라고 하며, 클래스에 속한 함수를 **메소드**라고 한다.
- 일부 프로그래밍 언어에서는 함수를 **프로시저** 또는 **서브루틴**이라고 한다.

## 매개변수와 인수의 차이

- 매개변수(parameter): 함수를 정의할 때 사용하는 변수(함수 인터페이스로 쓰는 변수)
- 인수(argument): 함수를 호출하며 전달하는 매개변수의 실제 값

<hr>

## 재귀와 반복

### 재귀

- 프로그래밍 영역에는 실행 도중 자기 자신을 호출하는 함수인 **재귀 함수**를 기본으로 제공하거나 직접 저의할 수 있다.
- 재귀 함수는 보통 특정 조건을 충족할 때까지 끊임없이 동작한다.
- 컴퓨터의 메모리에는 한계가 있으므로 재귀 함수가 자기 자신을 호출하는 횟수가 늘어날수록 컴퓨터의 가용 메모리 공간은 점점 줄어든다.
- 자기 자신을 호출하는 횟수의 한계인 **최대 재귀 깊이**(maximum recursion depth)를 넘어서면 **스택 오버플로우**(stack overflow)가 발생한다.

### 반복

- 반복은 재귀와 혼동해서는 안 되는 또 다른 개념이다.
- 알고리즘 내부에서의 반복이란 특정 조건을 충족할 때까지 코드 덩어리의 실행이 되풀이 되는 것을 의미한다.
- 반복에서 유의할 점은 재귀와 마찬가지로 컴퓨터 가용 메모리의한계 떄문에 반복의 종료 조건을 지정하지 않으면 프로그램에 에러가 발생한다는 것이다.

<hr>

## 알고리즘의 세 가지 유형

- 이 세가지 유형에는 **분할 정복 알고리즘**(divide and conquer algorithm),**탐욕 알고리즘**(greedy algorithm), **동적 프로그래밍**(dynamic programming)이 있다.
- **분할 정복 알고리즘**은 큰 문제를 작은 문제로 분할하고, 분할된 작은 문제를 해결한 다음, 해결된 작은 문제의 답을 모아서 큰 문제를 해결하는 알고리즘이다.
- **탐욕 알고리즘**은 최적화 문제를 해결하는 알고리즘으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- **동적 프로그래밍 알고리즘**은 과거에 내린 결정이 앞으로의 결정에 영향을 주는 알고리즘이다.
- 탐욕 알고리즘과 동적 프로그래밍 알고리즘 모두 문제를 더 작은 단위로 나누는 데 중점을 둔다는 공통점이 있지만, 탐욕 알고리즘은 특정 순간에 최적인 해결 방법을 찾고 동적 프로그래밍 알고리즘은 문제를 해결하는 다양한 해결 방법을 찾아 저장한 후 나중에 재사용한다는 점에 차이가 있다.

## 알고리즘 분석

- 알고리즘을 설계하는 것과 분석하는 것은 별개의 과정이다.
- 알고리즘을 설계한 뒤에는 알고리즘의 성능을 분석할 필요가 있다.
- 알고리즘의 효율성을 분석할 때는 **시간 복잡도**(time complexity)와 **공간 복잡도**(space complexity)의 두 가지 방법을 이용한다.

### 시간 복잡도

- 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 뜻한다.
- 시간 복잡도를 이용하는 알고리즘 분석은 알고리즘의 성능이 얼마나 효율적인지 알 수 있는 가장 일반적인 방법이다.

### 공간 복잡도

- 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻한다.
- 공간 복잡도를 이용하는 알고리즘 분석은 그리 많이 사용되지 않는다.
- 자원이 제한된 시스템에서 동작하는 프로그램을 구현하는 것과 같이 특별한 경우에 사용하는 분석방법이다.

## 알고리즘의 효율성 분석

- 알고리즘의 시간 복잡도를 분석하는 방법은 두 가지며, **실제적인 방법**과 **수학적인 방법**이 있다.
- 실제적인 방법은 입출력 데이터의 양이 알고리즘 동작에 미치는 영향을 관찰하고 기록하는 것이다.
- 하지만 실제적인 방법은 정확성이 떨어지고 사용 범위가 제한적이므로 이를 피하기 위해 수학적인 방법을 사용해야 한다.
- 알고리즘의 효율성을 수학적으로 판단하는 방법은 **점근적 분석**이라고도 한다.
- 이 분석 방법의 본질은 수학적으로 알고리즘 성능의 한계를 증명하는 것이므로 실제적인 방법보다 많은 시간을 절약할 수 있기도 하다.
- 구체적으로는 알고리즘의 성능이 최악이 되는 경계를 판단하거나 알고리즘의 평균 성능을 찾으며, 이떄 알고리즘 사이의 **점근적 증가율**(Asymptotic Growth Rate)을 비교하기 위해 **빅 오 표기법**을 사용한다.

<hr>

## 빅 오 표기법

- 알고리즘의 효율성을 설명할 때 다양한 표기법이 존재하지만 여러 표기법 중에서 점근적 분석에 가장 많이 사용되는 표기법이 **빅 오 표기법**이다.
- 빅 오라는 이름에서 대문자 **O**는 시간 복잡도의 정도를 나타내는 표기법인 차수(order)를 의미한다.
- 빅 오 표기법은 알고리즘을 실행하는데 걸리는 최대 시간을 측정하고, 본질은 알고리즘의 실행 시간이 최악인 경우를 나타내는 것이다.

### 빅 오 표기법으로 실행 시간을 나타내는 방법은 여러 가지며, 주로 다음과 같이 분류할 수 있다.

- O(1): 상수형 알고리즘이며, 데이터 입력량과 무관하게 실행시간이 일정하다.
- O(n): 선형 알고리즘이며, 데이터 입력량에 비례하여 실행 시간이 늘어난다.
- O($\log{n}$): 로그형 알고리즘이며, 시간이 선형적으로 증가하면 $n$이 기하급수적으로 증가한다. 이는 데이터 입력량이 늘어날수록 단위 입력당 실행 시간이 줄어든다는 뜻이다.
- O($n\log{n}$): 선형-로그형 알고리즘이며, 데이터 입력량이 $n$배 늘어나면 실행 시간이 $n$배 조금 넘게 늘어난다 .
- O($n^2$): 2차 알고리즘이며, 데이터 입력량의 제곱에 비례하여 실행 시간이 늘어난다.
- O($2^n$): 지수형 알고리즘이며, 데이터 입력이 추가될 때 마다 실행 시간이 2배로 늘어난다.
- O($n!$): 팩토리얼형 알고리즘이며, 데이터 입력이 추가될 때마다 실행 시간이 $n$배로 늘어난다.

이것은 가장 대중적인 분류방법이다. 알고리즘 성능이 좋은 순서대로 나열하면 **O(1)**, **O**($\log{n}$), **O(n)**, **O**($n\log{n}$), **O**($n^2$), **O**($2^n$), **O**($n!$)과 같다.
